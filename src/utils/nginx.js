const { exec } = require('child_process');
const { promisify } = require('util');
const fs = require('fs').promises;
const path = require('path');
const logger = require('./logger');

const execAsync = promisify(exec);

const NGINX_SITES_AVAILABLE = '/etc/nginx/sites-available';
const NGINX_SITES_ENABLED = '/etc/nginx/sites-enabled';

/**
 * Generate nginx configuration for a domain
 */
async function generateNginxConfig(domain, port, containerName) {
  // Use domain as upstream name (unique per deployment)
  const upstreamName = domain.replace(/\./g, '_').replace(/-/g, '_');
  
  const configContent = `# Auto-generated by Vellaric-Signal
# Container: ${containerName}
# Generated: ${new Date().toISOString()}

upstream ${upstreamName} {
    server 127.0.0.1:${port};
    keepalive 64;
}

server {
    listen 80;
    listen [::]:80;
    server_name ${domain};

    location / {
        proxy_pass http://${upstreamName};
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
        proxy_read_timeout 300s;
        proxy_connect_timeout 75s;
    }

    # Certbot will add SSL configuration here
    # Note: SSL is not enabled until certbot runs successfully
}
`;

  const configPath = path.join(NGINX_SITES_AVAILABLE, domain);
  const enabledPath = path.join(NGINX_SITES_ENABLED, domain);

  try {
    // Check if SSL is already configured
    let existingSSL = '';
    try {
      const existingConfig = await fs.readFile(configPath, 'utf8');
      // Extract SSL configuration if it exists (lines added by certbot)
      const sslMatch = existingConfig.match(/\n\s*listen.*443 ssl.*\n[\s\S]*?# managed by Certbot[\s\S]*?(?=\nserver\s*{|$)/);
      if (sslMatch) {
        existingSSL = sslMatch[0];
        logger.info(`Preserving existing SSL configuration for ${domain}`);
      }
    } catch (err) {
      // No existing config or can't read it
    }

    // Write fresh config without old SSL - let certbot re-add it
    let finalConfig = configContent;
    
    // Remove old symlink
    try {
      await fs.unlink(enabledPath);
    } catch (err) {
      // Ignore if doesn't exist
    }
    
    // Write nginx config
    await fs.writeFile(configPath, finalConfig);
    logger.info(`Nginx config written: ${configPath}`);

    // Create symlink
    await fs.symlink(configPath, enabledPath);
    logger.info(`Nginx config enabled: ${enabledPath}`);

    // Test nginx configuration
    const { stdout, stderr } = await execAsync('nginx -t');
    logger.debug('Nginx test:', stdout || stderr);

  } catch (error) {
    logger.error('Error generating nginx config:', error);
    throw error;
  }
}

/**
 * Reload nginx configuration
 */
async function reloadNginx() {
  try {
    await execAsync('systemctl reload nginx');
    logger.info('Nginx reloaded successfully');
  } catch (error) {
    logger.error('Error reloading nginx:', error);
    throw error;
  }
}

/**
 * Remove nginx configuration for a domain
 */
async function removeNginxConfig(domain) {
  const configPath = path.join(NGINX_SITES_AVAILABLE, domain);
  const enabledPath = path.join(NGINX_SITES_ENABLED, domain);

  try {
    // Remove symlink
    await fs.unlink(enabledPath).catch(() => {});
    // Remove config file
    await fs.unlink(configPath).catch(() => {});
    
    await reloadNginx();
    logger.info(`Nginx config removed for: ${domain}`);
  } catch (error) {
    logger.error('Error removing nginx config:', error);
  }
}

module.exports = {
  generateNginxConfig,
  reloadNginx,
  removeNginxConfig,
};
